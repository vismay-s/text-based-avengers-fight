import json
import boto3
import logging
import os
import statistics
logging.getLogger().setLevel(logging.INFO)

dynamodb = boto3.client('dynamodb')
# Function to check all mandatory fields are present
def processCheck(data):
    # return -5 if ERP, DataObject fields are missing or have incorrect values
    ERP_values = [1,2]        # static 
    DataObjectValues = [1,2,3,4,5,6]  #static
    mandatory = {'erpid', 'dataObjectID', 'criteria', 'uniqueID'}
    print(data)
    check = [i for i in mandatory if i not in list(data)]
    check_msg = None
    if check:
        msg_string = ','.join(check)
        check_msg = f"Mandatory {msg_string} Field(s) missing"
    else:                                                        # If fields are there we check their values.
        if not data["criteria"]:
            check_msg = "No data passed in criteria"
        if data["dataObjectID"] not in DataObjectValues:
            check_msg = "Invalid Data Object ID passed."
        if data["erpid"] not in ERP_values:
            check_msg = "Invalid ERP ID passed."
    flag = -5 if check_msg else 1
    return check_msg, flag


def urlSelector(data):
    if data["erpid"] == 1:
        ERP = "SAP"
    if data["erpid"] == 2:
        ERP = "Oracle"
    return ERP


def CIM(data, flag):
    query_erp = data["erpid"]  # assigning ERP ID to variable for query string building
    dobj = data["dataObjectID"]
    field_data = data['criteria'].copy()
    parent = {}
    for i in list(field_data):
        if i.isnumeric() == True:
            parent[list(field_data[i])[0]] = list(field_data[i].values())[0]  # assign fields with numeric keys to parent
            del field_data[i]                                                 # pop them out of the other one
        elif i.isnumeric() == False and not field_data[i]:
            del field_data[i]                                                 # pop out empty child collections
        elif i.isnumeric() == False and type(field_data[i]) is not list:
            flag=-7 
    query_param = None        
    field_set = set()       # set definition (Used as an important tie-breaker for error handling)
    

    if flag==1 and parent:  # condition where parent exists
    
        query = "SELECT field_label, common_name FROM AIQ_DB_Table WHERE field_mapping_type_ID=? and data_object_ID=? and field_position = '0'"
        params = [{'S': str(query_erp)}, {'S': str(dobj)}]
        response = dynamodb.execute_statement(Statement=query, Parameters=params)["Items"]
        d1 = [{k:list(v.values())[0] for k,v in i.items()} for i in response]
        reference = {i["common_name"]:i["field_label"] for i in d1}
        print(reference)
        for i in list(parent):
            query_param = i.replace(" ", "")  # whitespace removal
            field_set.add(query_param)       
            if reference.get(i):
                parent[reference[i]]=parent.pop(i)  
            else:  # unsuccesful or empty query response
                flag = -2  # flag for incorrect generic name from frontend
                break 
    
    if field_data and flag == 1:
        fd = field_data.copy()  # so as to not alter the dictionary length while looping
        m = []   # will store the actual child collection names
        
        query = "SELECT field_label, field_child_name, common_name FROM AIQ_DB_Table WHERE field_mapping_type_ID=? and data_object_ID=? and field_position = '1'"
        params = [{'S': str(query_erp)},{'S':str(dobj)}]
        response = dynamodb.execute_statement(Statement=query, Parameters=params)["Items"]
        d1 = [{k:list(v.values())[0] for k,v in i.items()} for i in response]
        
        reference = {i["common_name"]:[i["field_label"], i["field_child_name"]] for i in d1}
        
        for i in list(fd):  # for each child collection
            for j in enumerate(fd[i]): # for each dictionary group in the child
                nc = []                # The names collection which will be used to assign child table name based on majority rule
                for query_param in list(j[1]):  # for each field in the dictionary group
                    if reference.get(query_param):
                        field_data[i][j[0]][reference[query_param][0]] = field_data[i][j[0]].pop(query_param)
                        if "(" not in reference[query_param][1]:
                            nc.append(reference[query_param][1])
                        else:
                            flds = reference[query_param][1][1:-1]
                            for elem in flds.split(","):                        
                                nc.append(elem.strip()) 

                    else:
                        flag = -2  # flag for incorrect generic name from frontend
                        break
                else:
                    continue
                break
            else:
                if flag != -2:
                    if statistics.mode(nc) not in m:
                        m.append(statistics.mode(nc))
                        logging.info(f"This is the majority based child list----------- {m}")
                        logging.info(f"This is Name Collector List -------- {nc}")
                continue
            break   
    
        field_data = dict(zip(m,field_data.values()))
        
    return parent, field_data, flag, query_param, list(field_set) 


def lambda_handler(event, context):
    # print(event)
    inputdata = event["data"]
    # data, flag = CM(inputdata)  # step to execute when CIM data is ready
    check_msg, flag = processCheck(inputdata)  # testing method to assign flag statically.
    if flag != -5:
        data,child, flag, last_field, field_set = CIM(inputdata, flag)
        logging.info(f'This is FLAG after CIM function {flag}')
        ERP = urlSelector(inputdata)
        
        output = {
            'parent': data, 
            'child': child,
            'dataObjectID':inputdata["dataObjectID"],
            'ERP': ERP,
            'flag': flag,
            'uniqueID':inputdata["uniqueID"],
            'last_field':last_field,
            'field_set': field_set
        }
    else:
        output = {"status": "Failure",
                  "message": check_msg,
                  'ERP': 'None'
                  }
    logging.info(output)  
    return output       